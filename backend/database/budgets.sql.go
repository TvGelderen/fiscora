// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: budgets.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createBudget = `-- name: CreateBudget :one
INSERT INTO budgets (id, user_id, name, description, amount, start_date, end_date, created, updated)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, user_id, name, description, amount, start_date, end_date, created, updated
`

type CreateBudgetParams struct {
	ID          string
	UserID      uuid.UUID
	Name        string
	Description string
	Amount      string
	StartDate   time.Time
	EndDate     time.Time
	Created     time.Time
	Updated     time.Time
}

func (q *Queries) CreateBudget(ctx context.Context, arg CreateBudgetParams) (Budget, error) {
	row := q.db.QueryRowContext(ctx, createBudget,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Amount,
		arg.StartDate,
		arg.EndDate,
		arg.Created,
		arg.Updated,
	)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Amount,
		&i.StartDate,
		&i.EndDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const createBudgetExpense = `-- name: CreateBudgetExpense :one
INSERT INTO budget_expenses (budget_id, name, description, allocated_amount, current_amount)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, budget_id, name, description, allocated_amount, current_amount
`

type CreateBudgetExpenseParams struct {
	BudgetID        string
	Name            string
	Description     string
	AllocatedAmount string
	CurrentAmount   string
}

func (q *Queries) CreateBudgetExpense(ctx context.Context, arg CreateBudgetExpenseParams) (BudgetExpense, error) {
	row := q.db.QueryRowContext(ctx, createBudgetExpense,
		arg.BudgetID,
		arg.Name,
		arg.Description,
		arg.AllocatedAmount,
		arg.CurrentAmount,
	)
	var i BudgetExpense
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.Name,
		&i.Description,
		&i.AllocatedAmount,
		&i.CurrentAmount,
	)
	return i, err
}

const deleteBudget = `-- name: DeleteBudget :exec
DELETE FROM budgets 
WHERE id = $1 AND user_id = $2
`

type DeleteBudgetParams struct {
	ID     string
	UserID uuid.UUID
}

func (q *Queries) DeleteBudget(ctx context.Context, arg DeleteBudgetParams) error {
	_, err := q.db.ExecContext(ctx, deleteBudget, arg.ID, arg.UserID)
	return err
}

const getBudgets = `-- name: GetBudgets :many
SELECT id, user_id, name, description, amount, start_date, end_date, created, updated FROM budgets
WHERE user_id = $1
LIMIT $2
OFFSET $3
`

type GetBudgetsParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

func (q *Queries) GetBudgets(ctx context.Context, arg GetBudgetsParams) ([]Budget, error) {
	rows, err := q.db.QueryContext(ctx, getBudgets, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Budget
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Amount,
			&i.StartDate,
			&i.EndDate,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBudgetsWithExpenses = `-- name: GetBudgetsWithExpenses :many
SELECT budgets.id, user_id, budgets.name, budgets.description, amount, start_date, end_date, created, updated, budget_expenses.id, budget_id, budget_expenses.name, budget_expenses.description, allocated_amount, current_amount FROM budgets JOIN budget_expenses ON budgets.id = budget_expenses.budget_id
WHERE budgets.user_id = $1
LIMIT $2
OFFSET $3
`

type GetBudgetsWithExpensesParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetBudgetsWithExpensesRow struct {
	ID              string
	UserID          uuid.UUID
	Name            string
	Description     string
	Amount          string
	StartDate       time.Time
	EndDate         time.Time
	Created         time.Time
	Updated         time.Time
	ID_2            int32
	BudgetID        string
	Name_2          string
	Description_2   string
	AllocatedAmount string
	CurrentAmount   string
}

func (q *Queries) GetBudgetsWithExpenses(ctx context.Context, arg GetBudgetsWithExpensesParams) ([]GetBudgetsWithExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, getBudgetsWithExpenses, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBudgetsWithExpensesRow
	for rows.Next() {
		var i GetBudgetsWithExpensesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Amount,
			&i.StartDate,
			&i.EndDate,
			&i.Created,
			&i.Updated,
			&i.ID_2,
			&i.BudgetID,
			&i.Name_2,
			&i.Description_2,
			&i.AllocatedAmount,
			&i.CurrentAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBudget = `-- name: UpdateBudget :one
UPDATE budgets
SET name = $3, description = $4, amount = $5, start_date = $6, end_date = $7, updated = $8
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, name, description, amount, start_date, end_date, created, updated
`

type UpdateBudgetParams struct {
	ID          string
	UserID      uuid.UUID
	Name        string
	Description string
	Amount      string
	StartDate   time.Time
	EndDate     time.Time
	Updated     time.Time
}

func (q *Queries) UpdateBudget(ctx context.Context, arg UpdateBudgetParams) (Budget, error) {
	row := q.db.QueryRowContext(ctx, updateBudget,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Amount,
		arg.StartDate,
		arg.EndDate,
		arg.Updated,
	)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Amount,
		&i.StartDate,
		&i.EndDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateBudgetExpense = `-- name: UpdateBudgetExpense :one
UPDATE budget_expenses 
SET name = $2, description = $3, allocated_amount = $4, current_amount = $5
WHERE id = $1
RETURNING id, budget_id, name, description, allocated_amount, current_amount
`

type UpdateBudgetExpenseParams struct {
	ID              int32
	Name            string
	Description     string
	AllocatedAmount string
	CurrentAmount   string
}

func (q *Queries) UpdateBudgetExpense(ctx context.Context, arg UpdateBudgetExpenseParams) (BudgetExpense, error) {
	row := q.db.QueryRowContext(ctx, updateBudgetExpense,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.AllocatedAmount,
		arg.CurrentAmount,
	)
	var i BudgetExpense
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.Name,
		&i.Description,
		&i.AllocatedAmount,
		&i.CurrentAmount,
	)
	return i, err
}
